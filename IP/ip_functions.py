import numpy as np  
import cv2 
from os import getcwd
from sys import path 
from skimage import io
# modules imported

# database management functions

path.append( getcwd() + '/Database Management')

from db_functions import insertData, createTable, getLastPoint

"""
initialising basic variables and functions
"""

def see_img( img, frame_name= 'frame', is_directory = False):
	"""
	INPUT:\n
	directory is the string that contains the directory of image\n
	if already loaded then pass True in is_array.\n
	OUTPUT:\n
	Image in another window\n
	Returns the shape of the image\n
	INSTRUCTIONS:\n
	Press any key to close image\n
	"""
	if is_directory:
		img = cv2.imread( img, 1)

	cv2.imshow( frame_name, img)
	cv2.waitKey( 0)
	cv2.destroyWindow( frame_name)

	return img.shape

# variables having effect on output
class_confidence_thresh = 0.5 							# confidence chosen above which we classify
nms_thresh_val = 0.4									# threshold value for non maxima supression
required_classes= [ 2, 3, 5, 7] 						# classes chosen from yolo to classify
other_classes= [ 0, 1, 9]						# classes that may be important
classes_to_identify = [ 2, 3, 5, 7, 0, 1, 9]	# all the classes to be classified
# removed fire hydrant and stop sign from detections

"""
intialising YOLO
YOLOv3 files needs to be stored in the current working directory
"""
this_folder_dir = getcwd()
yolo_folder = this_folder_dir + '/yolo files'

# getting required files
yolo_classes_file = yolo_folder + '/yolov3.txt'
yolo_weights_file = yolo_folder + '/yolov3.weights'
yolo_config_file = yolo_folder + '/yolov3.cfg'

# reading the yolo classes file
with open( yolo_classes_file, 'r') as ycf:
	yolo_classes = ycf.read().splitlines()

# reading pre-trained model and config file (YOLO)
net = cv2.dnn.readNet( yolo_weights_file, yolo_config_file)

# getting the layer names that we need from YOLO
ln = net.getLayerNames()
ln = [ln[i[0] - 1] for i in net.getUnconnectedOutLayers()]

"""
writing required functions
"""

def get_information( yolo_output, height, width):
	"""
	INPUT:
	yolo_output contains the output generated by passing the blob through the net
	height and width are the image's height and width respectively
	OUTPUT:
	outputs an array having same dimension as the classes_to_identify with the elements being the count of the class
	"""
	pred_confidences = []
	pred_classIDs = []
	pred_boxes = []
	box_def_array = np.array([width, height, width, height])

	for output in yolo_output:
		for detection in output:

			# extracting probabilities and classes assigned from current object
			scores = detection[5:]
			classID = np.argmax(scores)
			confidence = scores[classID]

			# filtering out classes that have lowest confidences
			if confidence > class_confidence_thresh:

				# filtering out classes that do not need to be classified
				if classID in classes_to_identify:

					# adding the required information
					pred_confidences.append( float( confidence))
					pred_classIDs.append( classID)

					# creating boxes 
					# YOLO gives info about the centres and the height and width of box 
					temp_box= detection[0:4] * box_def_array
					(centerX, centerY, width, height) = temp_box.astype("int") 

					# defining coordinates of top left corner of the box
					X = int( centerX - ( width / 2))
					Y = int( centerY - ( height / 2))

					pred_boxes.append( [X, Y, int( width), int( height)])
	
	# applying non maxima supression
	if len( pred_boxes) > 0:
		indexes_to_keep = cv2.dnn.NMSBoxes( pred_boxes, pred_confidences, class_confidence_thresh, nms_thresh_val)
		indexes_to_keep = indexes_to_keep.flatten()
	else:
		return 'no classes identified'
	
	ret_array = np.zeros( len( classes_to_identify), dtype= 'int')

	for indx in indexes_to_keep:
		detd_class = pred_classIDs[indx]

		# the return array would contain the number of elements detected as chosen in the classes to identify
		ret_array[ classes_to_identify.index( detd_class)] += 1
	
	return ret_array


def apply_yolo( image):
	"""
	INPUT:\n
	takes in the image only\n
	OUTPUT:\n
	outputs the array outputted when the image is passed through the yolo net\n
	"""

	# creating input blob
	scale = 0.00392 # deifnes the scale of the image 1/255
	blob = cv2.dnn.blobFromImage(image, scale, (416,416), swapRB= True, crop= False)

	# setting blob as input
	net.setInput( blob)

	# running YOLO and getting outputs
	yolo_output = net.forward( ln)

	return yolo_output 


def detect_class_in_img( image, camera_id, is_url= False, is_directory= False):
	"""
	INPUT:\n
	takes the image in which the objects need to be detected\n
	camera id contains the id for the camera\n
	if the image variable is a url or a directory pass true in the respective variables\n
	OUTPUT:\n
	the array containing the counts of the objects detected\n
	"""
	if is_url:
		image = io.imread( image)
		image = cv2.cvtColor( image, cv2.COLOR_RGB2BGR)
	elif is_directory:
		image = cv2.imread( image, 1)
		
	information = get_information( apply_yolo( image), image.shape[0], image.shape[1])

	vehicle_db_dir = getcwd() + '//ML//vehicleData.db'

	createTable( db_dir= vehicle_db_dir, table_name= camera_id, func= 'vehicle', if_id= True)
	insertData( db_dir= vehicle_db_dir, table_name= camera_id, data= information, func= 'vehicle', if_id= True)

	return information

